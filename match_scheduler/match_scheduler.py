# Note, most initial contents were generated by ChatGPT
import logging
import random
import time
from itertools import product
from pathlib import Path
from typing import List, Optional, Tuple

import networkx as nx

LOGGER = logging.getLogger(__name__)
# Descriptive Type Aliases
Player = int
Team = List[Player]
Match = Tuple[Team, Team]


def print_log(values):
    # capture transcript into log file
    print(values)
    LOGGER.debug(values)


def num_rest(
    total_players: int, courts: int, team_sizes: List[int], num_teams: int
) -> int:
    """Find out how many resting players there are for a given config of players

    Args:
        total_players (int):
        courts (int):
        team_sizes (List[int]): preferential list of teams. NOTE currently only descending order supported
        num_teams (int): teams per match

    Raises:
        ValueError: if we can't find a solution of resting players

    Returns:
        int: _description_
    """
    available_courts = courts
    for team_size in team_sizes:
        resting = total_players - available_courts * team_size * num_teams
        if resting >= 0:
            return resting
        else:
            # fewer players than courts
            num_full_matches = total_players // (team_size * num_teams)
            total_players -= (team_size * num_teams) * num_full_matches
            available_courts -= num_full_matches
            if total_players == 0:  # no more players left, spare courts
                return 0
    return total_players
    # raise ValueError("Cannot find a solution for resting players")


class BadmintonSchedulerGraph:
    def __init__(self, players: List[Player], courts: int = 3) -> None:
        """
        Initialize the scheduler with players and a fixed number of courts.

        :param players: List of player IDs (integers).
        :param courts: Number of courts available for matches, defaults to 3.
        """
        LOGGER.debug(
            "Init Badminton graph with %s players and %s courts",
            len(players),
            courts,
        )
        self.players: List[Player] = players
        self.active_players: List[Player] = (
            players.copy()
        )  # Active players who are currently playing
        self.inactive_players: List[Player] = []  # Players sitting out
        self.courts = courts
        # Graph to track who has played against whom
        self.mg = nx.MultiGraph(incoming_graph_data=None, round=0)
        # set of allowable team sizes, sorted in preference
        self.team_size: List[int] = [2, 1]
        self.num_teams = 2  # in one game/match
        self.mg.add_nodes_from(
            players, rest=0, rests=[]  # adds rest and rests as node attributes
        )  # Add players as nodes

    def update_graph_with_matches(self, matches: List[Match]) -> None:
        """
        Update the internal graph with match data.

        :param matches: List of matches played in this round.
        """
        self.mg.graph["round"] += 1
        for match in matches:
            for team in match:
                self.add_teammate_edges(team)
            self.add_opponent_edges(*match)
        # add rests
        rest_players = self.get_resting_players(matches)
        for player in rest_players + self.inactive_players:
            self.add_player_rest(player)

    def add_teammate_edges(self, team: Team) -> None:
        """
        Update or add teammate edges between players in a team.

        :param team: List of players in a team (can be one or more players).
        """
        # Handle singles as a special case (player is their own teammate)
        if len(team) == 1:
            player: Player = team[0]
            team = [player] * 2
        # Add edges between teammates
        p1, p2 = team
        if self.mg.has_edge(p1, p2, key="team"):
            self.mg[p1][p2]["team"]["weight"] += 1
        else:
            self.mg.add_edge(p1, p2, weight=1, key="team")

    def add_opponent_edges(self, pair1: Team, pair2: Team) -> None:
        """
        Update or add opponent edges between two teams.

        :param pair1: First team (list of player IDs).
        :param pair2: Second team (list of player IDs).
        """
        for p1, p2 in product(pair1, pair2):
            if self.mg.has_edge(p1, p2, key="opp"):
                self.mg[p1][p2]["opp"]["weight"] += 1
            else:
                self.mg.add_edge(p1, p2, weight=1, key="opp")

    def add_player_rest(self, player: Player) -> None:
        """
        Update or add rest edges on a player.

        :param player: player id
        """

        self.mg.nodes[player]["rest"] = self.mg.graph["round"]
        self.mg.nodes[player]["rests"].append(self.mg.graph["round"])

    def num_rest(self) -> int:
        return num_rest(
            len(self.active_players),
            self.courts,
            self.team_size,
            self.num_teams,
        )

    def find_new_matches(self) -> List[Match]:
        """
        Find new matches for the current round based on the graph state.

        :return: A list of matches where each match is a tuple of two teams (pairs or singles).
        """
        # sort players by most recent rests TODO then by number of rests.
        num_rest = self.num_rest()
        if num_rest:
            self.active_players.sort(key=lambda p: self.mg.nodes[p]["rest"])
            lowest_rest = self.mg.nodes[self.active_players[0]][
                "rest"
            ]  # lowest rest
            highest_rest = self.mg.nodes[self.active_players[num_rest - 1]][
                "rest"
            ]
            # get all players with the same rest stats
            same_rest_players = [
                player
                for player in self.active_players
                if self.mg.nodes[player]["rest"]
                in range(lowest_rest, highest_rest + 1)
            ]
            # randomise them and take num_rest at random
            random.shuffle(same_rest_players)
            rest_players = same_rest_players[:num_rest]
            match_players = [
                player
                for player in self.active_players
                if player not in rest_players
            ]
        else:
            match_players = self.active_players

        random.shuffle(match_players)
        matches: List[Match] = []
        # Create doubles matches first
        pidx: int = 0  # player index
        while ((pidx + 3) < len(match_players)) and (
            len(matches) < self.courts
        ):
            pair1: Team = match_players[pidx : pidx + 2]
            pair2: Team = match_players[pidx + 2 : pidx + 4]
            matches.append((pair1, pair2))
            pidx += 4

        # If courts are available, add a singles match
        if len(matches) < self.courts and len(match_players) - pidx >= 2:
            matches.append(([match_players[pidx]], [match_players[pidx + 1]]))

        matches.sort(key=self.match_cost)
        return matches[: self.courts]

    def match_cost(self, match: Match) -> int:
        """
        Calculate the cost of a match based on the number of times players have faced each other.

        :param match: A tuple representing a match with two teams.
        :return: The total cost of the match (sum of opponent and teammate costs).
        """
        pair1, pair2 = match
        cost: int = 0

        # Calculate opponent cost
        for p1, p2 in product(pair1, pair2):
            if self.mg.has_edge(p1, p2, key="opp"):
                cost += self.mg[p1][p2]["opp"]["weight"]

        # Add teammate cost
        cost += self.teammate_cost(pair1) + self.teammate_cost(pair2)
        return cost

    def rest_cost(self, player: Player) -> int:
        """
        NOT USED
        Calculate the cost a player having rested recently

        :param team: player IDs in a team.
        :return: The total player cost.
        """
        # Calculate cost
        cost: int = 0
        if self.mg.has_edge(player, player, key="rest"):
            cost += self.mg[player][player]["rest"]["weight"]
        return cost

    def teammate_cost(self, team: Team) -> int:
        """
        Calculate the cost for teammates playing together.

        :param team: List of player IDs in a team.
        :return: The total teammate cost.
        """
        cost: int = 0
        if len(team) == 1:  # Handle singles match as a special case
            team = team * 2
        p1, p2 = team
        if self.mg.has_edge(p1, p2, key="teammate"):
            cost += self.mg[p1][p2]["teammate"]
        return cost

    def toggle_player(self, player: Player) -> None:
        """
        Toggle the player's active/inactive state.

        :param player: Player ID to toggle.
        """
        if player in self.active_players:
            self.active_players.remove(player)
            self.inactive_players.append(player)
            print_log(f"Player {player} is now inactive.")
        elif player in self.inactive_players:
            self.inactive_players.remove(player)
            self.active_players.append(player)
            print_log(f"Player {player} is now active again.")
        else:
            print_log(f"Player {player} is not part of the session.")

    def add_player(self, new_player: Player) -> None:
        """
        Add a new player to the session.

        :param new_player: New player ID to add.
        """
        self.players.append(new_player)
        self.active_players.append(new_player)
        self.mg.add_node(new_player, rest=self.mg.graph["round"], rests=[])
        print_log(f"Player {new_player} has been added.")

    def drop_players(self, dropped_indices: List[int]) -> None:
        """
        Drop players from the session based on their indices.

        :param dropped_indices: List of indices representing the players to drop.
        """
        dropped_players = [self.active_players[i] for i in dropped_indices]
        for player in dropped_players:
            self.toggle_player(player)

    def get_resting_players(self, matches: List[Match]) -> List[Player]:
        """
        Get a list of players who are not playing in the current round.

        :param matches: List of current matches.
        :return: List of resting player IDs.
        """
        matched_players = []
        for match in matches:
            # concat players to one iterable
            matched_players += list(sum(match, []))
        return [p for p in self.active_players if p not in matched_players]

    def print_current_status(self) -> None:
        """
        print_log the current status of active, resting, and inactive players.
        """
        total_players: int = len(self.players)
        print_log(
            f"Active players ({len(self.active_players)}/{total_players}): {sorted(self.active_players)}"
        )
        print_log(
            f"Inactive players ({len(self.inactive_players)}/{total_players}): {sorted(self.inactive_players)}"
        )


def handle_player_actions(
    scheduler: BadmintonSchedulerGraph, actions: List[int]
) -> None:
    for player in actions:
        if player in scheduler.players:
            scheduler.toggle_player(player)
        else:
            scheduler.add_player(player)


# Utility function to prompt user for player actions (toggle or add players)
def prompt_player_actions(scheduler: BadmintonSchedulerGraph) -> None:
    """
    Prompt the user for actions to toggle or add players, then move to the next round once we've confirmed.

    :param scheduler: The BadmintonSchedulerGraph instance.
    """
    prompt_str = "Enter player numbers (separated by spaces) to toggle or add (new numbers will be added). y to move to next round. q to quit:"
    while True:
        scheduler.print_current_status()
        action_input = input(prompt_str)
        if action_input.lower() == "y":
            break
        elif action_input.lower() == "q":
            raise KeyboardInterrupt
        else:
            actions = [
                int(num) for num in action_input.split() if num.isdigit()
            ]
            handle_player_actions(scheduler, actions)


# Main loop to run the scheduling
def main():
    LOGGER.info("Application started")
    initial_players = int(input("Enter the number of initial players: "))
    initial_courts = int(input("Enter the number of initial court: "))
    players = list(
        range(1, int(initial_players) + 1)
    )  # Player IDs start from 1
    courts = initial_courts
    scheduler = BadmintonSchedulerGraph(players, courts)

    round_number = 1
    while (
        len(sorted(scheduler.active_players)) > 3
    ):  # Need at least 4 active players to continue matches
        print_log(f"\n--- Round {round_number} ---")

        # Generate initial matches or new matches based on remaining players
        matches = scheduler.find_new_matches()

        print_log(f"Round {round_number} matches:")
        for i, match in enumerate(matches):
            print_log(f"\tCourt {i+1} : {match}")

        # Update the graph with new matches
        scheduler.update_graph_with_matches(matches)

        # Show resting players
        resting_players = sorted(
            scheduler.get_resting_players(matches)
        )  # Sorting resting players
        if resting_players:
            print_log(
                f"Resting players ({len(resting_players)}): {resting_players}"
            )
        else:
            print_log("No players are resting this round.")

        # Prompt for player actions (toggle or add players)
        try:
            prompt_player_actions(scheduler)
        except KeyboardInterrupt:
            print_log("Exiting scheduler")
            return

        # Update player list and courts for the next round
        round_number += 1


def setup_logging():
    timestr = time.strftime("%Y-%m-%d", time.gmtime())
    logfile_dir = Path("logs")
    logfile_dir.mkdir(parents=True, exist_ok=True)
    logfile_name = f"{timestr}-schedule.log"
    logfile_path = logfile_dir / logfile_name
    logging.basicConfig(
        filename=logfile_path,
        level=logging.DEBUG,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )
    rootlog = logging.getLogger()
    # create console handler and set level to debug
    ch = logging.StreamHandler()
    ch.setLevel(logging.INFO)

    # create formatter
    formatter = logging.Formatter("%(levelname)s:%(message)s")
    # normal CLI messages will use print, logging is just for additional info.

    # add formatter to ch
    ch.setFormatter(formatter)

    # add ch to logger
    rootlog.addHandler(ch)
    return rootlog


if __name__ == "__main__":
    setup_logging()
    try:
        main()
    except Exception as err:
        # make sure it gets logged
        LOGGER.exception(err)
        raise err
