# Note, most initial contents were generated by ChatGPT
import random

import networkx as nx


class BadmintonSchedulerGraph:
    def __init__(self, players, courts):
        self.players = players
        self.active_players = players.copy()  # Active players who are currently playing
        self.inactive_players = []  # Players sitting out
        self.courts = courts
        self.graph = nx.Graph()  # Graph to track who has played against whom
        self.graph.add_nodes_from(players)  # Add players as nodes

    def generate_initial_matches(self):
        random.shuffle(self.active_players)
        matches = []
        i = 0
        while i + 3 < len(self.active_players) and len(matches) < self.courts:
            pair1 = self.active_players[i:i+2]
            pair2 = self.active_players[i+2:i+4]
            matches.append((pair1, pair2))
            i += 4
        if len(matches) < self.courts and len(self.active_players) - i >= 2:
            # Add a singles match if needed to fill available courts
            matches.append(([self.active_players[i]], [self.active_players[i+1]]))
        return matches

    def update_graph_with_matches(self, matches):
        for match in matches:
            pair1, pair2 = match

            # Update edges between teammates
            self.add_teammate_edges(pair1)
            self.add_teammate_edges(pair2)

            # Add edges between opponents
            for p1 in pair1:
                for p2 in pair2:
                    if self.graph.has_edge(p1, p2):
                        self.graph[p1][p2]['weight'] += 1  # Increment the weight for repeated opponents
                    else:
                        self.graph.add_edge(p1, p2, weight=1, teammate_weight=0)  # First time, initialize both weights

    def add_teammate_edges(self, team):
        # If a player is in a singles match, they are their own teammate
        if len(team) == 1:
            player = team[0]
            if self.graph.has_edge(player, player):
                self.graph[player][player]['teammate_weight'] += 1
            else:
                self.graph.add_edge(player, player, weight=0, teammate_weight=1)  # Initialize weights
        else:
            # Add edges between teammates in doubles
            for p1 in team:
                for p2 in team:
                    if p1 != p2:
                        if self.graph.has_edge(p1, p2):
                            self.graph[p1][p2]['teammate_weight'] += 1
                        else:
                            self.graph.add_edge(p1, p2, weight=0, teammate_weight=1)  # Initialize weights

    def find_new_matches(self):
        random.shuffle(self.active_players)
        potential_matches = []

        # Prioritize doubles matches
        i = 0
        while i + 3 < len(self.active_players) and len(potential_matches) < self.courts:
            pair1 = [self.active_players[i], self.active_players[i+1]]
            pair2 = [self.active_players[i+2], self.active_players[i+3]]
            potential_matches.append((pair1, pair2))
            i += 4

        # If courts are still available and there are 2 players left, add a singles match
        if len(potential_matches) < self.courts and len(self.active_players) - i >= 2:
            potential_matches.append(([self.active_players[i]], [self.active_players[i+1]]))

        # Sort potential matches based on the weight of the edges between opponents and teammates
        potential_matches.sort(key=lambda match: self.match_cost(match))

        # Pick the best possible matches
        return potential_matches[:self.courts]

    def match_cost(self, match):
        # Calculate the cost of a match based on how often the players have faced each other (opponent and teammate)
        cost = 0
        pair1, pair2 = match

        # Calculate opponent cost
        for p1 in pair1:
            for p2 in pair2:
                if self.graph.has_edge(p1, p2):
                    cost += self.graph[p1][p2]['weight']

        # Calculate teammate cost (also applied in singles where player is their own teammate)
        cost += self.teammate_cost(pair1) + self.teammate_cost(pair2)

        return cost

    def teammate_cost(self, team):
        # Teammate cost includes singles as a special case (player is their own teammate)
        cost = 0
        if len(team) == 1:
            player = team[0]
            if self.graph.has_edge(player, player):
                cost += self.graph[player][player]['teammate_weight']
        else:
            for p1 in team:
                for p2 in team:
                    if p1 != p2 and self.graph.has_edge(p1, p2):
                        cost += self.graph[p1][p2]['teammate_weight']
        return cost

    def toggle_player(self, player):
        # Toggle player in and out of active list
        if player in self.active_players:
            self.active_players.remove(player)
            self.inactive_players.append(player)
            print(f"Player {player} is now inactive.")
        elif player in self.inactive_players:
            self.inactive_players.remove(player)
            self.active_players.append(player)
            print(f"Player {player} is now active again.")
        else:
            print(f"Player {player} is not part of the session.")

    def add_player(self, new_player):
        # Add a new player with no match history
        self.players.append(new_player)
        self.active_players.append(new_player)
        self.graph.add_node(new_player)  # Add the new player as a node in the graph
        print(f"Player {new_player} has been added.")

    def drop_players(self, dropped_indices):
        # Drop players from the graph but keep their edges intact for when they come back
        dropped_players = [self.active_players[i] for i in dropped_indices]
        for player in dropped_players:
            if player in self.active_players:
                self.toggle_player(player)

        # Update the number of available courts based on remaining active players
        self.courts = min(3, len(self.active_players) // 4)

    def get_resting_players(self, matches):
        # Find active players who are not in a match
        matched_players = set(p for match in matches for pair in match for p in pair)
        resting_players = [p for p in self.active_players if p not in matched_players]
        return resting_players

# Utility function to prompt user for player actions (toggle or add players)
def prompt_player_actions(scheduler):
    print("Current active players:", sorted(scheduler.active_players))  # Sorting active players
    print("Current inactive players:", sorted(scheduler.inactive_players))  # Sorting inactive players

    action_input = input("Enter player numbers (separated by spaces) to toggle or add (new numbers will be added): ")
    if action_input:
        actions = list(map(int, action_input.split()))
        for action in actions:
            if action in scheduler.active_players or action in scheduler.inactive_players:
                scheduler.toggle_player(action)
            else:
                scheduler.add_player(action)

# Main loop to run the scheduling
def main():
    initial_player_count = int(input("Enter the number of initial players: "))
    players = list(range(1, initial_player_count + 1))  # Player IDs start from 1
    courts = 3
    scheduler = BadmintonSchedulerGraph(players, courts)

    round_number = 1
    while len(sorted(scheduler.active_players)) > 3:  # Need at least 4 active players to continue matches
        print(f"\n--- Round {round_number} ---")

        # Generate initial matches or new matches based on remaining players
        if round_number == 1:
            matches = scheduler.generate_initial_matches()
        else:
            matches = scheduler.find_new_matches()

        print(f"Round {round_number} matches: {matches}")

        # Update the graph with new matches
        scheduler.update_graph_with_matches(matches)

        # Show resting players
        resting_players = sorted(scheduler.get_resting_players(matches))  # Sorting resting players
        if resting_players:
            print(f"Resting players: {resting_players}")
        else:
            print("No players are resting this round.")

        # Prompt for player actions (toggle or add players)
        prompt_player_actions(scheduler)

        # Update player list and courts for the next round
        round_number += 1

if __name__ == "__main__":
    main()
